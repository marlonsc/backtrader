"""order.py module.

Description of the module functionality."""

# -*- coding: utf-8; py-indent-offset:4 -*-
###############################################################################
#
# Copyright (C) 2015-2024 Daniel Rodriguez
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################
from __future__ import (
    absolute_import,
    division,
    print_function,
    unicode_literals,
)

import collections
import datetime
import itertools
from copy import copy

from .metabase import MetaParams
from .utils.autodict import AutoOrderedDict
from .utils.py3 import iteritems, range, with_metaclass


class OrderExecutionBit(object):
    """Holds information about a single order execution event. All docstrings and
comments must be line-wrapped at 90 characters or less.
Member Attributes:
- dt: datetime (float) execution time
- size: how much was executed
- price: execution price
- closed: how much of the execution closed an existing position
- opened: how much of the execution opened a new position
- openedvalue: market value of the "opened" part
- closedvalue: market value of the "closed" part
- closedcomm: commission for the "closed" part
- openedcomm: commission for the "opened" part
- value: market value for the entire bit size
- comm: commission for the entire bit execution
- pnl: pnl generated by this bit (if something was closed)
- psize: current open position size
- pprice: current open position price"""

    def __init__(
        self,
        dt=None,
        size=0,
        price=0.0,
        closed=0,
        closedvalue=0.0,
        closedcomm=0.0,
        opened=0,
        openedvalue=0.0,
        openedcomm=0.0,
        pnl=0.0,
        psize=0,
        pprice=0.0,
    ):
"""Args::
    dt: (Default value = None)
    size: (Default value = 0)
    price: (Default value = 0.0)
    closed: (Default value = 0)
    closedvalue: (Default value = 0.0)
    closedcomm: (Default value = 0.0)
    opened: (Default value = 0)
    openedvalue: (Default value = 0.0)
    openedcomm: (Default value = 0.0)
    pnl: (Default value = 0.0)
    psize: (Default value = 0)
    pprice: (Default value = 0.0)"""
    pprice: (Default value = 0.0)"""

        self.dt = dt
        self.size = size
        self.price = price

        self.closed = closed
        self.opened = opened
        self.closedvalue = closedvalue
        self.openedvalue = openedvalue
        self.closedcomm = closedcomm
        self.openedcomm = openedcomm

        self.value = closedvalue + openedvalue
        self.comm = closedcomm + openedcomm
        self.pnl = pnl

        self.psize = psize
        self.pprice = pprice


class OrderData(object):
    """Holds actual order data for creation and execution. All docstrings and
comments must be line-wrapped at 90 characters or less.
Member Attributes:
- exbits : iterable of OrderExecutionBits for this OrderData
- dt: datetime (float) creation/execution time
- size: requested/executed size
- price: execution price
Note: if no price is given and no pricelimit is given, the closing
price at the time or order creation will be used as reference
- pricelimit: holds pricelimit for StopLimit (which has trigger first)
- trailamount: absolute price distance in trailing stops
- trailpercent: percentage price distance in trailing stops
- value: market value for the entire bit size
- comm: commission for the entire bit execution
- pnl: pnl generated by this bit (if something was closed)
- margin: margin incurred by the Order (if any)
- psize: current open position size
- pprice: current open position price"""

    # According to the docs, collections.deque is thread-safe with appends at
    # both ends, there will be no pop (nowhere) and therefore to know which the
    # new exbits are two indices are needed. At time of cloning (__copy__) the
    # indices can be updated to match the previous end, and the new end
    # (len(exbits)
    # Example: start 0, 0 -> islice(exbits, 0, 0) -> []
    # One added -> copy -> updated 0, 1 -> islice(exbits, 0, 1) -> [1 elem]
    # Other added -> copy -> updated 1, 2 -> islice(exbits, 1, 2) -> [1 elem]
    # "add" and "__copy__" happen always in the same thread (with all current
    # implementations) and therefore no append will happen during a copy and
    # the len of the exbits can be queried with no concerns about another
    # thread making an append and with no need for a lock

    def __init__(
        self,
        dt=None,
        size=0,
        price=0.0,
        pricelimit=0.0,
        remsize=0,
        pclose=0.0,
        trailamount=0.0,
        trailpercent=0.0,
    ):
"""Args::
    dt: (Default value = None)
    size: (Default value = 0)
    price: (Default value = 0.0)
    pricelimit: (Default value = 0.0)
    remsize: (Default value = 0)
    pclose: (Default value = 0.0)
    trailamount: (Default value = 0.0)
    trailpercent: (Default value = 0.0)"""
    trailpercent: (Default value = 0.0)"""

        self.pclose = pclose
        self.exbits = collections.deque()  # for historical purposes
        self.p1, self.p2 = 0, 0  # indices to pending notifications

        self.dt = dt
        self.size = size
        self.remsize = remsize
        self.price = price
        self.pricelimit = pricelimit
        self.trailamount = trailamount
        self.trailpercent = trailpercent

        if not pricelimit:
            # if no pricelimit is given, use the given price
            self.pricelimit = self.price

        if pricelimit and not price:
            # price must always be set if pricelimit is set ...
            self.price = pricelimit

        self.plimit = pricelimit

        self.value = 0.0
        self.comm = 0.0
        self.margin = None
        self.pnl = 0.0

        self.psize = 0
        self.pprice = 0

    def _getplimit(self):
""""""
"""Args::
    val:"""
""""""
"""Args::
    key:"""
"""Args::
    dt: 
    size: 
    price: 
    closed: (Default value = 0)
    closedvalue: (Default value = 0.0)
    closedcomm: (Default value = 0.0)
    opened: (Default value = 0)
    openedvalue: (Default value = 0.0)
    openedcomm: (Default value = 0.0)
    pnl: (Default value = 0.0)
    psize: (Default value = 0)
    pprice: (Default value = 0.0)"""
    pprice: (Default value = 0.0)"""

        self.addbit(
            OrderExecutionBit(
                dt,
                size,
                price,
                closed,
                closedvalue,
                closedcomm,
                opened,
                openedvalue,
                openedcomm,
                pnl,
                psize,
                pprice,
            )
        )

    def addbit(self, exbit):
"""Args::
    exbit:"""
""""""
""""""
""""""
""""""
"""Base class for all order types in Backtrader. All docstrings and comments
    must be line-wrapped at 90 characters or less."""
    """

    params = (
        ("owner", None),
        ("data", None),
        ("size", None),
        ("price", None),
        ("pricelimit", None),
        ("plimit", None),
        ("exectype", None),
        ("valid", None),
        ("tradeid", 0),
        ("oco", None),
        ("trailamount", None),
        ("trailpercent", None),
        ("parent", None),
        ("transmit", True),
        ("simulated", False),
        # To support historical order evaluation
        ("histnotify", False),
        ("orderId", 0),
    )

    DAY = datetime.timedelta()  # constant for DAY order identification

    # Time Restrictions for orders
    T_Close, T_Day, T_Date, T_None = range(4)

    # Volume Restrictions for orders
    V_None = range(1)

    (
        Market,
        Close,
        Limit,
        Stop,
        StopLimit,
        StopTrail,
        StopTrailLimit,
        Historical,
    ) = range(8)
    ExecTypes = [
        "Market",
        "Close",
        "Limit",
        "Stop",
        "StopLimit",
        "StopTrail",
        "StopTrailLimit",
        "Historical",
    ]

    OrdTypes = ["Buy", "Sell"]
    Buy, Sell = range(2)

    (
        Created,
        Submitted,
        Accepted,
        Partial,
        Completed,
        Canceled,
        Expired,
        Margin,
        Rejected,
    ) = range(9)

    Cancelled = Canceled  # alias

    Status = [
        "Created",
        "Submitted",
        "Accepted",
        "Partial",
        "Completed",
        "Canceled",
        "Expired",
        "Margin",
        "Rejected",
    ]

    refbasis = itertools.count(1)  # for a unique identifier per order

    def _getplimit(self):
""""""
"""Args::
    val:"""
"""Args::
    name:"""
"""Args::
    name: 
    value:"""
    value:"""
        if hasattr(self.params, name):
            setattr(self.params, name, value)
        else:
            super(OrderBase, self).__setattr__(name, value)

    def __str__(self):
""""""
""""""
""""""
"""Returns the name for a given status or the one of the order

Args::
    status: (Default value = None)"""
    status: (Default value = None)"""
        return self.Status[self.status if status is None else status]

    def getordername(self, exectype=None):
"""Returns the name for a given exectype or the one of the order

Args::
    exectype: (Default value = None)"""
    exectype: (Default value = None)"""
        return self.ExecTypes[self.exectype if exectype is None else exectype]

    @classmethod
    def ExecType(cls, exectype):
"""Args::
    exectype:"""
"""Returns the name for a given ordtype or the one of the order

Args::
    ordtype: (Default value = None)"""
    ordtype: (Default value = None)"""
        return self.OrdTypes[self.ordtype if ordtype is None else ordtype]

    def active(self):
""""""
""""""
"""Returns True if the order is in a status in which it can still be
        executed"""
        """
        return self.status in [
            Order.Created,
            Order.Submitted,
            Order.Partial,
            Order.Accepted,
        ]

    def addcomminfo(self, comminfo):
"""Stores a CommInfo scheme associated with the asset

Args::
    comminfo:"""
    comminfo:"""
        self.comminfo = comminfo

    def addinfo(self, **kwargs):
        """Add the keys, values of kwargs to the internal info dictionary to
hold custom information in the order"""
        for key, val in iteritems(kwargs):
            self.info[key] = val

    def __eq__(self, other):
"""Args::
    other:"""
"""Args::
    other:"""
        """Returns True if the order is a Buy order"""
        return self.ordtype == self.Buy

    def issell(self):
        """Returns True if the order is a Sell order"""
        return self.ordtype == self.Sell

    def setposition(self, position):
"""Receives the current position for the asset and stotres it

Args::
    position:"""
    position:"""
        self.position = position

    def submit(self, broker=None):
"""Marks an order as submitted and stores the broker to which it was
submitted

Args::
    broker: (Default value = None)"""
    broker: (Default value = None)"""
        self.status = Order.Submitted
        self.broker = broker
        self.plen = len(self.data)

    def accept(self, broker=None):
"""Marks an order as accepted

Args::
    broker: (Default value = None)"""
    broker: (Default value = None)"""
        self.status = Order.Accepted
        self.broker = broker

    def brokerstatus(self):
        """Tries to retrieve the status from the broker in which the order is.
Defaults to last known status if no broker is associated"""
        if self.broker:
            return self.broker.orderstatus(self)

        return self.status

    def reject(self, broker=None):
"""Marks an order as rejected

Args::
    broker: (Default value = None)"""
    broker: (Default value = None)"""
        if self.status == Order.Rejected:
            return False

        self.status = Order.Rejected
        self.broker = broker
        if not self.p.simulated:
            self.executed.dt = self.data.datetime[0]
        return True

    def cancel(self):
        """Marks an order as cancelled"""
        self.status = Order.Canceled
        if not self.p.simulated:
            self.executed.dt = self.data.datetime[0]

    def margin(self):
        """Marks an order as having met a margin call"""
        self.status = Order.Margin
        if not self.p.simulated:
            self.executed.dt = self.data.datetime[0]

    def completed(self):
        """Marks an order as completely filled"""
        self.status = self.Completed

    def partial(self):
        """Marks an order as partially filled"""
        self.status = self.Partial

    def execute(
        self,
        dt,
        size,
        price,
        closed,
        closedvalue,
        closedcomm,
        opened,
        openedvalue,
        openedcomm,
        margin,
        pnl,
        psize,
        pprice,
    ):
"""Receives data execution input and stores it

Args::
    dt: 
    size: 
    price: 
    closed: 
    closedvalue: 
    closedcomm: 
    opened: 
    openedvalue: 
    openedcomm: 
    margin: 
    pnl: 
    psize: 
    pprice:"""
    pprice:"""
        if not size:
            return

        self.executed.add(
            dt,
            size,
            price,
            closed,
            closedvalue,
            closedcomm,
            opened,
            openedvalue,
            openedcomm,
            pnl,
            psize,
            pprice,
        )

        self.executed.margin = margin

    def expire(self):
        """Marks an order as expired. Returns True if it worked"""
        self.status = self.Expired
        return True

    def trailadjust(self, price):
"""Args::
    price:"""
    """Concrete order class for Backtrader. All docstrings and comments must be
line-wrapped at 90 characters or less.
The order may have the following status:
- Submitted: sent to the broker and awaiting confirmation
- Accepted: accepted by the broker
- Partial: partially executed
- Completed: fully exexcuted
- Canceled/Cancelled: canceled by the user
- Expired: expired
- Margin: not enough cash to execute the order.
- Rejected: Rejected by the broker
This can happen during order submission (and therefore the order will
not reach the Accepted status) or before execution with each new bar
price because cash has been drawn by other sources (future-like
instruments may have reduced the cash or orders orders may have been
executed)
Member Attributes:
- ref: unique order identifier
- created: OrderData holding creation data
- executed: OrderData holding execution data
- info: custom information passed over method :func:`addinfo`. It is kept
in the form of an OrderedDict which has been subclassed, so that keys
can also be specified using '.' notation
User Methods:
- isbuy(): returns bool indicating if the order buys
- issell(): returns bool indicating if the order sells
- alive(): returns bool if order is in status Partial or Accepted"""

    def execute(
        self,
        dt,
        size,
        price,
        closed,
        closedvalue,
        closedcomm,
        opened,
        openedvalue,
        openedcomm,
        margin,
        pnl,
        psize,
        pprice,
    ):
"""Args::
    dt: 
    size: 
    price: 
    closed: 
    closedvalue: 
    closedcomm: 
    opened: 
    openedvalue: 
    openedcomm: 
    margin: 
    pnl: 
    psize: 
    pprice:"""
    pprice:"""

        super(Order, self).execute(
            dt,
            size,
            price,
            closed,
            closedvalue,
            closedcomm,
            opened,
            openedvalue,
            openedcomm,
            margin,
            pnl,
            psize,
            pprice,
        )

        if self.executed.remsize:
            self.status = Order.Partial
        else:
            self.status = Order.Completed

        # self.comminfo = None

    def expire(self):
""""""
"""Args::
    price:"""
"""Concrete buy order class for Backtrader. All docstrings and comments must be
    line-wrapped at 90 characters or less."""
    """

    ordtype = Order.Buy


class StopBuyOrder(BuyOrder):
"""Stop buy order class for Backtrader. All docstrings and comments must be
    line-wrapped at 90 characters or less."""
    """


class StopLimitBuyOrder(BuyOrder):
"""Stop limit buy order class for Backtrader. All docstrings and comments must be
    line-wrapped at 90 characters or less."""
    """


class SellOrder(Order):
"""Concrete sell order class for Backtrader. All docstrings and comments must be
    line-wrapped at 90 characters or less."""
    """

    ordtype = Order.Sell


class StopSellOrder(SellOrder):
"""Stop sell order class for Backtrader. All docstrings and comments must be
    line-wrapped at 90 characters or less."""
    """


class StopLimitSellOrder(SellOrder):
"""Stop limit sell order class for Backtrader. All docstrings and comments must be
    line-wrapped at 90 characters or less."""
    """
